<!DOCTYPE html>
<html>
<head>
    <!--배열의 메소드-->
    <meta charset='utf-8'>
    <link rel="stylesheet" href="taskCSS_1.css" type="text/css">
</head>

<body>
    <script>
        // delete
        function exam1() {
            let arr = ['I', 'go', 'home'];
            delete arr[1];  //  ->  ["I",  , "home"]
            alert( arr[1] );  // undefined
            alert( arr.length );  // 3
        }
        // 단순히 해당 키의 값을 지우는 기능. length는 유지됨


        // splice
        /* arr.splice(index[, deleteCount, elem1, ..., elemN]) 
           index: 시작 / deleteCount: 제거할 개수 / elem: 추가할 요소
        */
        function exam2() {
            // 제거
            let arr1 = ['1', '2', '3', '4', '5']; 
            arr1.splice(1, 2);  // [1]부터 2개를 제거
            alert(arr1);  // 1,4,5 

            // 제거 후 추가
            let arr2 = ['1', '2', '3', '4', '5', '6'];
            arr2.splice(2, 3, 'a', 1);  // [2]부터 3개를 제거. 그 자리를 a, 1로 교체
            alert(arr2);  // 1,2,a,1,6
 
            // splice는 제거값을 배열로 반환함
            let arr3 = [1, 2, 3, 4, 5]; 
            let spArr = arr3.splice(1, 3);
            alert(spArr);  // 2,3,4
            alert( spArr[1] );  // 3  -> spArr이 진짜 배열임

        } 


        // splice 응용
        function exam3() {
            // 제거 없이 추가
            let arr1 = [1, 2, 3, 4, 5];
            arr1.splice(2, 0, '제거', '없이', '추가');  // [2]번째에 0개 제거
            alert(arr1);  // 1,2,제거,없이,추가,3,4,5


            // 음수 인덱스 사용 가능 (-0은 없고 뒤에서부터 -1)
            let arr2 = [1, 2, 5];

            arr2.splice(-1, 0, 3, 4);  // 3, 4 추가
            alert(arr2);  // 1,2,3,4,5
        }


        // arr.slice(start, end);
        /* 
          start부터 end까지(end 미포함) 인덱스 요소를 복사한 새 배열 반환
          arr.slice는 배열 반환. str.slice는 문자열 반환
        */
        function exam4() {
            let arr1 = [1, 2, 3, 4, 5];
            alert( arr1.slice(1, 3) );  // 2, 3
            alert( arr1.slice(-2) );  // 4, 5 
            // 인수를 하나도 안넘기면 복사본 만들기 가능
            alert( arr1.slice() );
        }

        // arr.concat(arg1, arg2...);
        // 배열에 인수를 추가. 인수로 배열도 가능
        function exam5() {
            let arr1 = [1, 2];
            alert( arr1.concat(3, 4) );  // 1, 2, 3, 4
            alert( arr1.concat( [3, 4], [5, 6]) );  // 1, 2, 3, 4, 5, 6 인수로 배열 가능
            arr2 = arr1.concat('a', 'b');
            alert(arr2);  // 1, 2, a, b

            // concat의 특별한 특징
            let arr = [1, 2];

            let arrayLike = {
                0: "something",
                1: "else",
                2: "??",
                length: 3
            };
            alert( arr.concat(arrayLike) ); // 1,2,[object Object]

            let arr_1 = [1, 2];

            let arrayLike_1 = {
                0: "something",
                1: "else",
                2: "??",
                [Symbol.isConcatSpreadable]: true,
                length: 3
            };
            alert( arr.concat(arrayLike_1) ); // 1,2,something,else,??

            // -> 유사 배열 객체에 Symbol.isConcatSpreadable가 true이면, concat은 객체를 배열처럼 취급.

        }

        // forEach
        // arr.forEach( function(item, index, array) )
        function exam6() {
            ["A1", "B2", "C3"].forEach((item, index, array) => {
                alert(`${item} is at index ${index} in ${array}`);
                // A1 is at index 0 in A1,B2,C3
                // B2 is at index 1 in A1,B2,C3
                // C3 is at index 2 in A1,B2,C3
            });
        }


        




    </script>

    <a href="#" onclick="exam1();">#1</a>
    <a href="#" onclick="exam2();">#2</a>
    <a href="#" onclick="exam3();">#3</a>
    <a href="#" onclick="exam4();">#4</a>
    <a href="#" onclick="exam5();">#5</a>
    <a href="#" onclick="exam6();">#6</a>
  
</body>
</html>